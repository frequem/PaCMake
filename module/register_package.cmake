pacmake_include(package_version)

include(CMakeParseArguments)

# pacmake_register_package(packageVersion [DEPENDENCIES [dependency1Name dependency1Version] [...]] [SOURCES ...] [CMAKE_ARGS ...])
function(pacmake_register_package packageVersion)
	if(${packageVersion} IN_LIST PACMAKE_PACKAGE_${PACMAKE_CURRENT_PACKAGE}_VERSIONS)
		message(FATAL_ERROR "PaCMake: pacmake_register_package(${PACMAKE_CURRENT_PACKAGE}): Duplicate package version (${packageVersion}).")
	endif()
	
	cmake_parse_arguments(args "" "" "DEPENDENCIES;SOURCES;CMAKE_ARGS" ${ARGN})
	
	set(packageName ${PACMAKE_CURRENT_PACKAGE}) # save package name overwritten by dependency loading
	set(dependencyNames "")
	set(dependencyVersions "")
	set(dependencyTypes "")
	if(args_DEPENDENCIES) # load dependencies at register time to avoid circular dependency on add
		set(firstDependencyType TRUE)
		list(LENGTH args_DEPENDENCIES nDependencies)
		set(i 1)
		while(i LESS ${nDependencies})
			math(EXPR iDependencyName "${i} - 1")
			list(GET args_DEPENDENCIES ${iDependencyName} dependencyName)
			math(EXPR iDependencyVersionRequested "${i}")
			list(GET args_DEPENDENCIES ${iDependencyVersionRequested} dependencyVersionRequested)
			math(EXPR iPossibleDependencyType "${i} + 1")
			set(dependencyType "")
			if(${iPossibleDependencyType} LESS ${nDependencies})
				list(GET args_DEPENDENCIES ${iPossibleDependencyType} possibleDependencyType)
				set(possibleDependencyTypes "STATIC;SHARED;MODULE;DEFAULT;INHERIT")
				if("${possibleDependencyType}" IN_LIST possibleDependencyTypes)
					set(dependencyType "${possibleDependencyType}")
				endif()
			endif()
			if(dependencyType)
				math(EXPR i "${i} + 3")
			else()
				math(EXPR i "${i} + 2")
				set(dependencyType "INHERIT")
			endif()
			
			if(NOT packageName STREQUAL dependencyName)
				pacmake_load_package(${dependencyName})
			endif()
			
			pacmake_find_package_version(${dependencyName} ${dependencyVersionRequested} dependencyVersion) # error if no compatible version is found
			
			if(dependencyNames)
				list(LENGTH dependencyNames nPrevDependencyNames)
				set(j 0)
				while(${j} LESS ${nPrevDependencyNames})
					list(GET dependencyNames ${j} prevDependencyName)
					list(GET dependencyVersions ${j} prevDependencyVersion)
					if(prevDependencyName STREQUAL dependencyName AND prevDependencyVersion STREQUAL dependencyVersion)
						break()
					endif()
					
					math(EXPR j "${j} + 1")
				endwhile()
				if(${j} LESS ${nPrevDependencyNames})
					message(FATAL_ERROR "PaCMake: pacmake_register_package(${packageName} ${packageVersion}): Duplicate dependency(${dependencyName} ${dependencyVersion}).")
				endif()
			endif()
			
			list(APPEND dependencyNames "${dependencyName}")
			list(APPEND dependencyVersions "${dependencyVersion}")
			list(APPEND dependencyTypes "${dependencyType}")
		endwhile()
		if(${i} LESS_EQUAL ${nDependencies})
			string(REPLACE ";" " " dependencyString "${args_DEPENDENCIES}")
			message(FATAL_ERROR "PaCMake: pacmake_register_package(${packageName} ${packageVersion}): Invalid dependencies: ${dependencyString}. Version missing?")
		endif()
	endif()
	
	set(PACMAKE_PACKAGE_${packageName}_${packageVersion}_DEPENDENCY_NAMES "${dependencyNames}" CACHE INTERNAL "")
	set(PACMAKE_PACKAGE_${packageName}_${packageVersion}_DEPENDENCY_VERSIONS "${dependencyVersions}" CACHE INTERNAL "")
	set(PACMAKE_PACKAGE_${packageName}_${packageVersion}_DEPENDENCY_TYPES "${dependencyTypes}" CACHE INTERNAL "")
	set(PACMAKE_PACKAGE_${packageName}_${packageVersion}_SOURCES "${args_SOURCES}" CACHE INTERNAL "")
	set(PACMAKE_PACKAGE_${packageName}_${packageVersion}_CMAKE_ARGS "${args_CMAKE_ARGS}" CACHE INTERNAL "")
	
	list(APPEND PACMAKE_PACKAGE_${packageName}_VERSIONS ${packageVersion})
	list(SORT PACMAKE_PACKAGE_${packageName}_VERSIONS COMPARE NATURAL ORDER DESCENDING)
	set(PACMAKE_PACKAGE_${packageName}_VERSIONS "${PACMAKE_PACKAGE_${packageName}_VERSIONS}" CACHE INTERNAL "")
endfunction(pacmake_register_package)
